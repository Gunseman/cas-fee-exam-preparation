# Fragen CAS-FEE - Prüfungsvorbereitung

## [16] 14.09.2016 - JUnit / Integration Testing

### Was ist der Unterschied eines Mock Object zu einem Stub Object?
von Benjamin Rüde - Dienstag, 29. November 2016, 17:59

a) Das Mock Object prüft auf Aufrufsparameter und liefert eine entsprechende Antwort zurück. Das Stub Object hingegen liefert ohne die Aufrufsparmeter zu prüfen eine vordefinierte Antwort.
b) Das Mock-Object wird sicher von der zu prüfenden Einheit aufgerufen, das Stub dient nur all Parameterfüller wird aber nie wirklich aufgerufen wären des Testlauf.
c) Das Mock Object dient der Visuellen Prüfung gegen Mockup Bilder während das Stub Object nur den Html-Code (Quellcode) prüft.
d) Stub Objects sind nur die Interfaces des zu ersetztenden Objects. Mock Objects besitzen hingegen eine komplette Implementierung aller Methoden.

Lösung:
b)

### Was sind die Vorteile von einem TDD Test
von Thomas Brandenburger - Mittwoch, 28. September 2016, 14:21

- Man schreibt den Test garantiert
- Bisherige Funktionalität wird gewährleistet
- Test demonstriert API des Codes

### Was ist BDD ?
von Philipp Bachmann - Dienstag, 20. September 2016, 13:04

BDD steht für "Behavior-Driven Development" und ist eine Erweiterung des Test-Driven Developments (kurz TDD). In BDD werden die Anforderungen meist in "Wenn-dann"-Sätzen und in Form von sogenannten User Stories verfasst. Dies soll die Zusammenarbeit zwischen Business Analysten und Entwicklern stärken.

Beispiel:  
> **Story: Returns go to stock**
>
> **In order** to keep track of stock  
> **As a** store owner  
> **I want to** add items back to stock when they're returned.  
>
> **Scenario 1:** Refunded items should be returned to stock  
> **Given that** a customer previously bought a black sweater from me
> **And** I have three black sweaters in stock.  
> **When** he returns the black sweater for a refund
> **Then** I should have four black sweaters in stock.

### Test Double Patterns: Nenne vier Ausprägungen
von Michel Rimbeaux - Montag, 19. September 2016, 17:44

1. [Test Stub](http://xunitpatterns.com/Test%20Stub.html)  
Wird verwendet für die Bereitstellung indirekten Inputs (**ingoing interface**) für den zu testenden Code ([SUT](http://xunitpatterns.com/SUT.html)).

2. [Mock Object](http://xunitpatterns.com/Mock%20Object.html)  
Wird verwendet, um indirekten Output (**outgoing interface**) des SUTs zu überprüfen, indem zuerst die Erwartungen definiert werden, bevor der zu testende Code ausgeführt wird.

3. [Test Spy](http://xunitpatterns.com/Test%20Spy.html)  
Wird verwendet, um indirekten Output (**outgoing interface**) des SUTs zu überprüfen, indem die Erwartungen definiert werden, nachdem das SUT ausgeführt wurde. Der Test Spy zeichnet alle Ausgaben des SUTs auf, um die erwarteten Ergebnisse hinterher zu verifizieren, ohne sie im Voraus zu kennen resp. definieren zu müssen. Der Test Spy ist somit eine einfache und intuitive Art, die existierenden Tests zu erweitern mit noch ungetesteten Anforderungen.

4. [Fake Object](http://xunitpatterns.com/Fake%20Object.html)  
Wird verwendet als einfache und leicht-gewichtige Implementierung, um eine SUT-abhängie Komponente ([DOC](http://xunitpatterns.com/DOC.html)) zu ersetzen, z.B. eine In-Memory-Datenbank anstelle einer realen Datenbank.

### Nenne drei unit test smells
von Marc Labud - Donnerstag, 15. September 2016, 13:43

Schwer testbar geschriebener Sourcecode
Der Sourcecode erschwert das Schreiben von automatisierbaren Tests, da einzelne Units nicht ohne Änderung des Sourcecodes für den Test isoliert werden können.

*Produktionsfehler*  
In der formalen Testphase oder in Produktion treten (zu) viele Fehler auf.

*Zerbrechliche Tests*  
Ein Test kann nicht durchgeführt werden, wenn das System unter Test (SUT) geändert wird und diese Änderung keinen geplanten Einfluss auf die Ausführung der Testfälle  haben sollte.

*Nicht zuverlässig wiederholbare Testergebnisse*  
Es gibt Tests, die mal erfolgreich ausgeführt werden und mal scheitern, ohne das die Störungsursache bekannt ist.

*Es gibt keine automatisierten Tests*  
Die Entwickler schreiben keine automatisierbaren Tests.

### Was ist der Unterschied zwischen Continuous Delivery + Continuous Deployment?
von Fabio Cavalera - Donnerstag, 15. September 2016, 07:54

Der Begriff Continuos Delivery beschreibt den automatischen Build und Publish Prozess auf ein Testenvironment

Beim Continous Deployment hingegen wird das generierte Paket auf den produktiven WebServer publiziert, sprich der Endkunde sieht die Änderung dann sofort.

### Warum ist folgende Klasse schlecht Testbar? Wie kann man sie verbessern?
von Patrik Dietschweiler - Mittwoch, 14. September 2016, 19:04

```javascript
class AuthentificationService{

    private _http : HttpConnection;

    constructor(){
        this._http = new HttpConnection();
    }
    public login(username : string, password: string) : Promise<boolean>{
        return this._http.post("https://myserver.ch/api/login",
        {username:username, password: password}).map(result => result.status == 204);
    }
}
```

Die AuthentificationService Klasse hat eine Abhängigkeit zur HttpConnection. Diese Abhängigkeit kann in den Test nicht durch ein Double ersetzt werden, weil sie im Konstruktor erzeugt wird.

Verbesserungsansatz:

Die HttpConnection Abhängigkeit sollte über den Konstruktor injected werden. Somit kann die HttpConnection in den Tests durch ein Vererbtes Double ersetz werden.

```javascript
class AuthentificationService{
    constructor(private _http : HttpConnection){
    }
    public login(username : string, password: string) : Promise<bool>{
        return this._http.post("https://myserver.ch/api/login",
        {username:username, password: password}).map(result => result.status == 204);
    }
}
```

### Welche 3 Kategorien von Tests gibt es?
von Rafael Bamert - Mittwoch, 14. September 2016, 18:27

- Unit Tests
- Integration Tests
- System Tests

### Nenne die 4 Phasen eines Test Cases
von Anton Kammermeier - Mittwoch, 14. September 2016, 17:41

1. Setup
2. Exercise
3. Verify
4. Teardown

### Was sind die wichtigsten Argumente für automatisiertes Testen im Front-End Umfeld?
von Stefan Eugster - Mittwoch, 12. Oktober 2016, 12:18

- immer komplexere Applikationen
- immer höhere Anforderungen an Verfügbarkeiet der Applikationen (hohe Kosten bei Downtime)
- Wartbarkeit der Applikationen über längere Zeit
- Refactoring einer Applikation kann sehr schwierig sein ohne Unit tests
